FC-INT-CHECK
check `find-name`:
#t
`FC I proj`:
`fc-source`:
'((read name namelist valuelist)
  (search (if (equal? name (car namelist)) goto found goto cont))
  (cont (valuelist := cdr valuelist) (namelist := cdr namelist) (goto search))
  (found (return car valuelist)))
`fc-target-1`:
'((read Env)
  (0 (Env := make-immutable-hash (zip '(name namelist valuelist) Env)) (if (int-expr Env '(equal? name (car namelist))) goto 1 goto 2))
  (1 (return (int-expr Env '(car valuelist))))
  (2
   (Env := dict-set Env 'valuelist (int-expr Env '(cdr valuelist)))
   (Env := dict-set Env 'namelist (int-expr Env '(cdr namelist)))
   (if (int-expr Env '(equal? name (car namelist))) goto 1 goto 2)))
check `fc-target-1`:
#t
`FC II proj`:
`fc-proj2/comp`:
'((read vs0)
  (0 (Pending := list->set (list (cons 'int (make-immutable-hash vs0)))) (Marked := list->set ()) (Res := '((read Env))) (if (set-empty? Pending) goto 12 goto 1))
  (1
   (PPVS := set-first Pending)
   (PP := car PPVS)
   (VS := cdr PPVS)
   (Pending := set-rest Pending)
   (Marked := set-add Marked PPVS)
   (BB
    :=
    hash-ref
    '#hash((cont . ((Action := car AssignJump) (goto is-assign)))
           (do-assign . ((Env := dict-set Env (car Action) (int-expr Env (unqu (cddr Action)))) (AssignJump := cdr AssignJump) (goto is-not-empty)))
           (do-goto . ((AssignJump := dict-ref Program (second Action)) (goto is-not-empty)))
           (do-if . ((if (int-expr Env (second Action)) goto if-true goto if-false)))
           (do-return . ((return (int-expr Env (unqu (cdr Action))))))
           (error . ((return ('syntaxerror))))
           (if-false . ((AssignJump := dict-ref Program (sixth Action)) (goto is-not-empty)))
           (if-true . ((AssignJump := dict-ref Program (fourth Action)) (goto is-not-empty)))
           (int . ((Env := make-immutable-hash (zip (cdar Program) Env)) (AssignJump := cdadr Program) (Program := make-immutable-hash (cdr Program)) (goto is-not-empty)))
           (is-assign . ((if (equal? (second Action) ':=) goto do-assign goto is-goto)))
           (is-goto . ((if (equal? (first Action) 'goto) goto do-goto goto is-if)))
           (is-if . ((if (equal? (first Action) 'if) goto do-if goto is-return)))
           (is-not-empty . ((if (null? AssignJump) goto error goto cont)))
           (is-return . ((if (equal? (first Action) 'return) goto do-return goto error))))
    PP
    ())
   (Code := list (env-label PP VS))
   (if (empty? BB) goto 18 goto 2))
  (2 (Command := car BB) (BB := cdr BB) (if (equal? (second Command) ':=) goto 5 goto 3))
  (3 (if (equal? (car Command) 'goto) goto 4 goto 7))
  (4
   (BB
    :=
    hash-ref
    '#hash((cont . ((Action := car AssignJump) (goto is-assign)))
           (do-assign . ((Env := dict-set Env (car Action) (int-expr Env (unqu (cddr Action)))) (AssignJump := cdr AssignJump) (goto is-not-empty)))
           (do-goto . ((AssignJump := dict-ref Program (second Action)) (goto is-not-empty)))
           (do-if . ((if (int-expr Env (second Action)) goto if-true goto if-false)))
           (do-return . ((return (int-expr Env (unqu (cdr Action))))))
           (error . ((return ('syntaxerror))))
           (if-false . ((AssignJump := dict-ref Program (sixth Action)) (goto is-not-empty)))
           (if-true . ((AssignJump := dict-ref Program (fourth Action)) (goto is-not-empty)))
           (int . ((Env := make-immutable-hash (zip (cdar Program) Env)) (AssignJump := cdadr Program) (Program := make-immutable-hash (cdr Program)) (goto is-not-empty)))
           (is-assign . ((if (equal? (second Action) ':=) goto do-assign goto is-goto)))
           (is-goto . ((if (equal? (first Action) 'goto) goto do-goto goto is-if)))
           (is-if . ((if (equal? (first Action) 'if) goto do-if goto is-return)))
           (is-not-empty . ((if (null? AssignJump) goto error goto cont)))
           (is-return . ((if (equal? (first Action) 'return) goto do-return goto error))))
    (second Command)
    ())
   (if (empty? BB) goto 18 goto 2))
  (5 (if (is-static (first Command) '(Program AssignJump Action)) goto 8 goto 6))
  (6 (Code := append Code (list (append (list (first Command) ':=) (reduce (cddr Command) VS)))) (if (empty? BB) goto 18 goto 2))
  (7 (if (equal? (car Command) 'if) goto 13 goto 9))
  (8 (VS := update-vs VS (first Command) (cddr Command)) (if (empty? BB) goto 18 goto 2))
  (9 (if (equal? (car Command) 'return) goto 11 goto 10))
  (10 (return error "MIX: error instruction"))
  (11 (Code := append Code (list (append '(return) (reduce (cdr Command) VS)))) (if (empty? BB) goto 18 goto 2))
  (12 (return Res))
  (13 (if (is-static (second Command) '(Program AssignJump Action)) goto 15 goto 14))
  (14
   (Pending := update-pending Pending VS Marked (fourth Command) (sixth Command))
   (Code := append Code (list (append (append '(if) (list (reduce (second Command) VS))) (list 'goto (env-label (fourth Command) VS) 'goto (env-label (sixth Command) VS)))))
   (if (empty? BB) goto 18 goto 2))
  (15 (if (int-expr (hash->list VS) (second Command)) goto 16 goto 17))
  (16
   (BB
    :=
    hash-ref
    '#hash((cont . ((Action := car AssignJump) (goto is-assign)))
           (do-assign . ((Env := dict-set Env (car Action) (int-expr Env (unqu (cddr Action)))) (AssignJump := cdr AssignJump) (goto is-not-empty)))
           (do-goto . ((AssignJump := dict-ref Program (second Action)) (goto is-not-empty)))
           (do-if . ((if (int-expr Env (second Action)) goto if-true goto if-false)))
           (do-return . ((return (int-expr Env (unqu (cdr Action))))))
           (error . ((return ('syntaxerror))))
           (if-false . ((AssignJump := dict-ref Program (sixth Action)) (goto is-not-empty)))
           (if-true . ((AssignJump := dict-ref Program (fourth Action)) (goto is-not-empty)))
           (int . ((Env := make-immutable-hash (zip (cdar Program) Env)) (AssignJump := cdadr Program) (Program := make-immutable-hash (cdr Program)) (goto is-not-empty)))
           (is-assign . ((if (equal? (second Action) ':=) goto do-assign goto is-goto)))
           (is-goto . ((if (equal? (first Action) 'goto) goto do-goto goto is-if)))
           (is-if . ((if (equal? (first Action) 'if) goto do-if goto is-return)))
           (is-not-empty . ((if (null? AssignJump) goto error goto cont)))
           (is-return . ((if (equal? (first Action) 'return) goto do-return goto error))))
    (fourth Command)
    ())
   (if (empty? BB) goto 18 goto 2))
  (17
   (BB
    :=
    hash-ref
    '#hash((cont . ((Action := car AssignJump) (goto is-assign)))
           (do-assign . ((Env := dict-set Env (car Action) (int-expr Env (unqu (cddr Action)))) (AssignJump := cdr AssignJump) (goto is-not-empty)))
           (do-goto . ((AssignJump := dict-ref Program (second Action)) (goto is-not-empty)))
           (do-if . ((if (int-expr Env (second Action)) goto if-true goto if-false)))
           (do-return . ((return (int-expr Env (unqu (cdr Action))))))
           (error . ((return ('syntaxerror))))
           (if-false . ((AssignJump := dict-ref Program (sixth Action)) (goto is-not-empty)))
           (if-true . ((AssignJump := dict-ref Program (fourth Action)) (goto is-not-empty)))
           (int . ((Env := make-immutable-hash (zip (cdar Program) Env)) (AssignJump := cdadr Program) (Program := make-immutable-hash (cdr Program)) (goto is-not-empty)))
           (is-assign . ((if (equal? (second Action) ':=) goto do-assign goto is-goto)))
           (is-goto . ((if (equal? (first Action) 'goto) goto do-goto goto is-if)))
           (is-if . ((if (equal? (first Action) 'if) goto do-if goto is-return)))
           (is-not-empty . ((if (null? AssignJump) goto error goto cont)))
           (is-return . ((if (equal? (first Action) 'return) goto do-return goto error))))
    (sixth Command)
    ())
   (if (empty? BB) goto 18 goto 2))
  (18 (Res := append Res (list Code)) (if (set-empty? Pending) goto 12 goto 1)))
`source`:
'((if 0 goto 3) (right) (goto 0) (write 1))
`fc-target-2`:
'((read Env)
  (0 (Env := make-immutable-hash (zip '(name namelist valuelist) Env)) (if (int-expr Env '(equal? name (car namelist))) goto 1 goto 2))
  (1 (return (int-expr Env '(car valuelist))))
  (2
   (Env := dict-set Env 'valuelist (int-expr Env '(cdr valuelist)))
   (Env := dict-set Env 'namelist (int-expr Env '(cdr namelist)))
   (if (int-expr Env '(equal? name (car namelist))) goto 1 goto 2)))
check `fc-target-2`:
#t
`FC III proj`:
`fc-proj3/cogen`:
'((read vs0)
  (0 (Pending := list->set (list (cons 'init (make-immutable-hash vs0)))) (Marked := list->set ()) (Res := '((read vs0))) (if (set-empty? Pending) goto 1 goto 2))
  (1 (return Res))
  (2
   (PPVS := set-first Pending)
   (PP := car PPVS)
   (VS := cdr PPVS)
   (Pending := set-rest Pending)
   (Marked := set-add Marked PPVS)
   (BB
    :=
    hash-ref
    '#hash((do-assign . ((if (is-static (first Command) static) goto do-static-assign goto do-dynamic-assign)))
           (do-dynamic-assign . ((Code := append Code (list (append (list (first Command) ':=) (reduce (cddr Command) VS)))) (goto inner-loop)))
           (do-dynamic-if
            .
            ((Pending := update-pending Pending VS Marked (fourth Command) (sixth Command))
             (Code
              :=
              append
              Code
              (list (append (append (list 'if) (list (reduce (second Command) VS))) (list 'goto (env-label (fourth Command) VS) 'goto (env-label (sixth Command) VS)))))
             (goto inner-loop)))
           (do-fail . ((return error "MIX: error instruction")))
           (do-goto . ((BB := hash-ref program (second Command) ()) (goto inner-loop)))
           (do-if . ((if (is-static (second Command) static) goto do-static-if goto do-dynamic-if)))
           (do-return . ((Code := append Code (list (append (list 'return) (reduce (cdr Command) VS)))) (goto inner-loop)))
           (do-static-assign . ((VS := update-vs VS (first Command) (cddr Command)) (goto inner-loop)))
           (do-static-if . ((if (int-expr (hash->list VS) (second Command)) goto do-static-if-true goto do-static-if-false)))
           (do-static-if-false . ((BB := hash-ref program (sixth Command) ()) (goto inner-loop)))
           (do-static-if-true . ((BB := hash-ref program (fourth Command) ()) (goto inner-loop)))
           (init .
                 ((Pending := list->set (list (cons (caadr program) (make-immutable-hash vs0))))
                  (static := car div)
                  (dynamic := cdr div)
                  (Marked := list->set ())
                  (Res := (list (cons 'read (set-subtract (cdar program) static))))
                  (program := make-immutable-hash (cdr program))
                  (goto loop)))
           (inner-loop . ((if (empty? BB) goto loop-end goto inner-loop-body)))
           (inner-loop-body . ((Command := car BB) (BB := cdr BB) (goto is-assign)))
           (is-assign . ((if (equal? (second Command) ':=) goto do-assign goto is-goto)))
           (is-goto . ((if (equal? (car Command) 'goto) goto do-goto goto is-if)))
           (is-if . ((if (equal? (car Command) 'if) goto do-if goto is-return)))
           (is-return . ((if (equal? (car Command) 'return) goto do-return goto do-fail)))
           (loop . ((if (set-empty? Pending) goto stop goto loop-begin)))
           (loop-begin
            .
            ((PPVS := set-first Pending)
             (PP := car PPVS)
             (VS := cdr PPVS)
             (Pending := set-rest Pending)
             (Marked := set-add Marked PPVS)
             (BB := hash-ref program PP ())
             (Code := list (env-label PP VS))
             (goto inner-loop)))
           (loop-end . ((Res := append Res (list Code)) (goto loop)))
           (stop . ((return Res))))
    PP
    ())
   (Code := list (env-label PP VS))
   (if (empty? BB) goto 6 goto 3))
  (3 (Command := car BB) (BB := cdr BB) (if (equal? (second Command) ':=) goto 4 goto 7))
  (4 (if (is-static (first Command) '(program div static dynamic)) goto 5 goto 18))
  (5 (VS := update-vs VS (first Command) (cddr Command)) (if (empty? BB) goto 6 goto 3))
  (6 (Res := append Res (list Code)) (if (set-empty? Pending) goto 1 goto 2))
  (7 (if (equal? (car Command) 'goto) goto 10 goto 8))
  (8 (if (equal? (car Command) 'if) goto 9 goto 12))
  (9 (if (is-static (second Command) '(program div static dynamic)) goto 15 goto 11))
  (10
   (BB
    :=
    hash-ref
    '#hash((do-assign . ((if (is-static (first Command) static) goto do-static-assign goto do-dynamic-assign)))
           (do-dynamic-assign . ((Code := append Code (list (append (list (first Command) ':=) (reduce (cddr Command) VS)))) (goto inner-loop)))
           (do-dynamic-if
            .
            ((Pending := update-pending Pending VS Marked (fourth Command) (sixth Command))
             (Code
              :=
              append
              Code
              (list (append (append (list 'if) (list (reduce (second Command) VS))) (list 'goto (env-label (fourth Command) VS) 'goto (env-label (sixth Command) VS)))))
             (goto inner-loop)))
           (do-fail . ((return error "MIX: error instruction")))
           (do-goto . ((BB := hash-ref program (second Command) ()) (goto inner-loop)))
           (do-if . ((if (is-static (second Command) static) goto do-static-if goto do-dynamic-if)))
           (do-return . ((Code := append Code (list (append (list 'return) (reduce (cdr Command) VS)))) (goto inner-loop)))
           (do-static-assign . ((VS := update-vs VS (first Command) (cddr Command)) (goto inner-loop)))
           (do-static-if . ((if (int-expr (hash->list VS) (second Command)) goto do-static-if-true goto do-static-if-false)))
           (do-static-if-false . ((BB := hash-ref program (sixth Command) ()) (goto inner-loop)))
           (do-static-if-true . ((BB := hash-ref program (fourth Command) ()) (goto inner-loop)))
           (init .
                 ((Pending := list->set (list (cons (caadr program) (make-immutable-hash vs0))))
                  (static := car div)
                  (dynamic := cdr div)
                  (Marked := list->set ())
                  (Res := (list (cons 'read (set-subtract (cdar program) static))))
                  (program := make-immutable-hash (cdr program))
                  (goto loop)))
           (inner-loop . ((if (empty? BB) goto loop-end goto inner-loop-body)))
           (inner-loop-body . ((Command := car BB) (BB := cdr BB) (goto is-assign)))
           (is-assign . ((if (equal? (second Command) ':=) goto do-assign goto is-goto)))
           (is-goto . ((if (equal? (car Command) 'goto) goto do-goto goto is-if)))
           (is-if . ((if (equal? (car Command) 'if) goto do-if goto is-return)))
           (is-return . ((if (equal? (car Command) 'return) goto do-return goto do-fail)))
           (loop . ((if (set-empty? Pending) goto stop goto loop-begin)))
           (loop-begin
            .
            ((PPVS := set-first Pending)
             (PP := car PPVS)
             (VS := cdr PPVS)
             (Pending := set-rest Pending)
             (Marked := set-add Marked PPVS)
             (BB := hash-ref program PP ())
             (Code := list (env-label PP VS))
             (goto inner-loop)))
           (loop-end . ((Res := append Res (list Code)) (goto loop)))
           (stop . ((return Res))))
    (second Command)
    ())
   (if (empty? BB) goto 6 goto 3))
  (11
   (Pending := update-pending Pending VS Marked (fourth Command) (sixth Command))
   (Code := append Code (list (append (append '(if) (list (reduce (second Command) VS))) (list 'goto (env-label (fourth Command) VS) 'goto (env-label (sixth Command) VS)))))
   (if (empty? BB) goto 6 goto 3))
  (12 (if (equal? (car Command) 'return) goto 13 goto 14))
  (13 (Code := append Code (list (append '(return) (reduce (cdr Command) VS)))) (if (empty? BB) goto 6 goto 3))
  (14 (return error "MIX: error instruction"))
  (15 (if (int-expr (hash->list VS) (second Command)) goto 17 goto 16))
  (16
   (BB
    :=
    hash-ref
    '#hash((do-assign . ((if (is-static (first Command) static) goto do-static-assign goto do-dynamic-assign)))
           (do-dynamic-assign . ((Code := append Code (list (append (list (first Command) ':=) (reduce (cddr Command) VS)))) (goto inner-loop)))
           (do-dynamic-if
            .
            ((Pending := update-pending Pending VS Marked (fourth Command) (sixth Command))
             (Code
              :=
              append
              Code
              (list (append (append (list 'if) (list (reduce (second Command) VS))) (list 'goto (env-label (fourth Command) VS) 'goto (env-label (sixth Command) VS)))))
             (goto inner-loop)))
           (do-fail . ((return error "MIX: error instruction")))
           (do-goto . ((BB := hash-ref program (second Command) ()) (goto inner-loop)))
           (do-if . ((if (is-static (second Command) static) goto do-static-if goto do-dynamic-if)))
           (do-return . ((Code := append Code (list (append (list 'return) (reduce (cdr Command) VS)))) (goto inner-loop)))
           (do-static-assign . ((VS := update-vs VS (first Command) (cddr Command)) (goto inner-loop)))
           (do-static-if . ((if (int-expr (hash->list VS) (second Command)) goto do-static-if-true goto do-static-if-false)))
           (do-static-if-false . ((BB := hash-ref program (sixth Command) ()) (goto inner-loop)))
           (do-static-if-true . ((BB := hash-ref program (fourth Command) ()) (goto inner-loop)))
           (init .
                 ((Pending := list->set (list (cons (caadr program) (make-immutable-hash vs0))))
                  (static := car div)
                  (dynamic := cdr div)
                  (Marked := list->set ())
                  (Res := (list (cons 'read (set-subtract (cdar program) static))))
                  (program := make-immutable-hash (cdr program))
                  (goto loop)))
           (inner-loop . ((if (empty? BB) goto loop-end goto inner-loop-body)))
           (inner-loop-body . ((Command := car BB) (BB := cdr BB) (goto is-assign)))
           (is-assign . ((if (equal? (second Command) ':=) goto do-assign goto is-goto)))
           (is-goto . ((if (equal? (car Command) 'goto) goto do-goto goto is-if)))
           (is-if . ((if (equal? (car Command) 'if) goto do-if goto is-return)))
           (is-return . ((if (equal? (car Command) 'return) goto do-return goto do-fail)))
           (loop . ((if (set-empty? Pending) goto stop goto loop-begin)))
           (loop-begin
            .
            ((PPVS := set-first Pending)
             (PP := car PPVS)
             (VS := cdr PPVS)
             (Pending := set-rest Pending)
             (Marked := set-add Marked PPVS)
             (BB := hash-ref program PP ())
             (Code := list (env-label PP VS))
             (goto inner-loop)))
           (loop-end . ((Res := append Res (list Code)) (goto loop)))
           (stop . ((return Res))))
    (sixth Command)
    ())
   (if (empty? BB) goto 6 goto 3))
  (17
   (BB
    :=
    hash-ref
    '#hash((do-assign . ((if (is-static (first Command) static) goto do-static-assign goto do-dynamic-assign)))
           (do-dynamic-assign . ((Code := append Code (list (append (list (first Command) ':=) (reduce (cddr Command) VS)))) (goto inner-loop)))
           (do-dynamic-if
            .
            ((Pending := update-pending Pending VS Marked (fourth Command) (sixth Command))
             (Code
              :=
              append
              Code
              (list (append (append (list 'if) (list (reduce (second Command) VS))) (list 'goto (env-label (fourth Command) VS) 'goto (env-label (sixth Command) VS)))))
             (goto inner-loop)))
           (do-fail . ((return error "MIX: error instruction")))
           (do-goto . ((BB := hash-ref program (second Command) ()) (goto inner-loop)))
           (do-if . ((if (is-static (second Command) static) goto do-static-if goto do-dynamic-if)))
           (do-return . ((Code := append Code (list (append (list 'return) (reduce (cdr Command) VS)))) (goto inner-loop)))
           (do-static-assign . ((VS := update-vs VS (first Command) (cddr Command)) (goto inner-loop)))
           (do-static-if . ((if (int-expr (hash->list VS) (second Command)) goto do-static-if-true goto do-static-if-false)))
           (do-static-if-false . ((BB := hash-ref program (sixth Command) ()) (goto inner-loop)))
           (do-static-if-true . ((BB := hash-ref program (fourth Command) ()) (goto inner-loop)))
           (init .
                 ((Pending := list->set (list (cons (caadr program) (make-immutable-hash vs0))))
                  (static := car div)
                  (dynamic := cdr div)
                  (Marked := list->set ())
                  (Res := (list (cons 'read (set-subtract (cdar program) static))))
                  (program := make-immutable-hash (cdr program))
                  (goto loop)))
           (inner-loop . ((if (empty? BB) goto loop-end goto inner-loop-body)))
           (inner-loop-body . ((Command := car BB) (BB := cdr BB) (goto is-assign)))
           (is-assign . ((if (equal? (second Command) ':=) goto do-assign goto is-goto)))
           (is-goto . ((if (equal? (car Command) 'goto) goto do-goto goto is-if)))
           (is-if . ((if (equal? (car Command) 'if) goto do-if goto is-return)))
           (is-return . ((if (equal? (car Command) 'return) goto do-return goto do-fail)))
           (loop . ((if (set-empty? Pending) goto stop goto loop-begin)))
           (loop-begin
            .
            ((PPVS := set-first Pending)
             (PP := car PPVS)
             (VS := cdr PPVS)
             (Pending := set-rest Pending)
             (Marked := set-add Marked PPVS)
             (BB := hash-ref program PP ())
             (Code := list (env-label PP VS))
             (goto inner-loop)))
           (loop-end . ((Res := append Res (list Code)) (goto loop)))
           (stop . ((return Res))))
    (fourth Command)
    ())
   (if (empty? BB) goto 6 goto 3))
  (18 (Code := append Code (list (append (list (first Command) ':=) (reduce (cddr Command) VS)))) (if (empty? BB) goto 6 goto 3)))
`fc-comp`:
'((read vs0)
  (0 (Pending := list->set (list (cons 'int (make-immutable-hash vs0)))) (Marked := list->set ()) (Res := '((read Env))) (if (set-empty? Pending) goto 12 goto 1))
  (1
   (PPVS := set-first Pending)
   (PP := car PPVS)
   (VS := cdr PPVS)
   (Pending := set-rest Pending)
   (Marked := set-add Marked PPVS)
   (BB
    :=
    hash-ref
    '#hash((cont . ((Action := car AssignJump) (goto is-assign)))
           (do-assign . ((Env := dict-set Env (car Action) (int-expr Env (unqu (cddr Action)))) (AssignJump := cdr AssignJump) (goto is-not-empty)))
           (do-goto . ((AssignJump := dict-ref Program (second Action)) (goto is-not-empty)))
           (do-if . ((if (int-expr Env (second Action)) goto if-true goto if-false)))
           (do-return . ((return (int-expr Env (unqu (cdr Action))))))
           (error . ((return ('syntaxerror))))
           (if-false . ((AssignJump := dict-ref Program (sixth Action)) (goto is-not-empty)))
           (if-true . ((AssignJump := dict-ref Program (fourth Action)) (goto is-not-empty)))
           (int . ((Env := make-immutable-hash (zip (cdar Program) Env)) (AssignJump := cdadr Program) (Program := make-immutable-hash (cdr Program)) (goto is-not-empty)))
           (is-assign . ((if (equal? (second Action) ':=) goto do-assign goto is-goto)))
           (is-goto . ((if (equal? (first Action) 'goto) goto do-goto goto is-if)))
           (is-if . ((if (equal? (first Action) 'if) goto do-if goto is-return)))
           (is-not-empty . ((if (null? AssignJump) goto error goto cont)))
           (is-return . ((if (equal? (first Action) 'return) goto do-return goto error))))
    PP
    ())
   (Code := list (env-label PP VS))
   (if (empty? BB) goto 18 goto 2))
  (2 (Command := car BB) (BB := cdr BB) (if (equal? (second Command) ':=) goto 5 goto 3))
  (3 (if (equal? (car Command) 'goto) goto 4 goto 7))
  (4
   (BB
    :=
    hash-ref
    '#hash((cont . ((Action := car AssignJump) (goto is-assign)))
           (do-assign . ((Env := dict-set Env (car Action) (int-expr Env (unqu (cddr Action)))) (AssignJump := cdr AssignJump) (goto is-not-empty)))
           (do-goto . ((AssignJump := dict-ref Program (second Action)) (goto is-not-empty)))
           (do-if . ((if (int-expr Env (second Action)) goto if-true goto if-false)))
           (do-return . ((return (int-expr Env (unqu (cdr Action))))))
           (error . ((return ('syntaxerror))))
           (if-false . ((AssignJump := dict-ref Program (sixth Action)) (goto is-not-empty)))
           (if-true . ((AssignJump := dict-ref Program (fourth Action)) (goto is-not-empty)))
           (int . ((Env := make-immutable-hash (zip (cdar Program) Env)) (AssignJump := cdadr Program) (Program := make-immutable-hash (cdr Program)) (goto is-not-empty)))
           (is-assign . ((if (equal? (second Action) ':=) goto do-assign goto is-goto)))
           (is-goto . ((if (equal? (first Action) 'goto) goto do-goto goto is-if)))
           (is-if . ((if (equal? (first Action) 'if) goto do-if goto is-return)))
           (is-not-empty . ((if (null? AssignJump) goto error goto cont)))
           (is-return . ((if (equal? (first Action) 'return) goto do-return goto error))))
    (second Command)
    ())
   (if (empty? BB) goto 18 goto 2))
  (5 (if (is-static (first Command) '(Program AssignJump Action)) goto 8 goto 6))
  (6 (Code := append Code (list (append (list (first Command) ':=) (reduce (cddr Command) VS)))) (if (empty? BB) goto 18 goto 2))
  (7 (if (equal? (car Command) 'if) goto 13 goto 9))
  (8 (VS := update-vs VS (first Command) (cddr Command)) (if (empty? BB) goto 18 goto 2))
  (9 (if (equal? (car Command) 'return) goto 11 goto 10))
  (10 (return error "MIX: error instruction"))
  (11 (Code := append Code (list (append '(return) (reduce (cdr Command) VS)))) (if (empty? BB) goto 18 goto 2))
  (12 (return Res))
  (13 (if (is-static (second Command) '(Program AssignJump Action)) goto 15 goto 14))
  (14
   (Pending := update-pending Pending VS Marked (fourth Command) (sixth Command))
   (Code := append Code (list (append (append '(if) (list (reduce (second Command) VS))) (list 'goto (env-label (fourth Command) VS) 'goto (env-label (sixth Command) VS)))))
   (if (empty? BB) goto 18 goto 2))
  (15 (if (int-expr (hash->list VS) (second Command)) goto 16 goto 17))
  (16
   (BB
    :=
    hash-ref
    '#hash((cont . ((Action := car AssignJump) (goto is-assign)))
           (do-assign . ((Env := dict-set Env (car Action) (int-expr Env (unqu (cddr Action)))) (AssignJump := cdr AssignJump) (goto is-not-empty)))
           (do-goto . ((AssignJump := dict-ref Program (second Action)) (goto is-not-empty)))
           (do-if . ((if (int-expr Env (second Action)) goto if-true goto if-false)))
           (do-return . ((return (int-expr Env (unqu (cdr Action))))))
           (error . ((return ('syntaxerror))))
           (if-false . ((AssignJump := dict-ref Program (sixth Action)) (goto is-not-empty)))
           (if-true . ((AssignJump := dict-ref Program (fourth Action)) (goto is-not-empty)))
           (int . ((Env := make-immutable-hash (zip (cdar Program) Env)) (AssignJump := cdadr Program) (Program := make-immutable-hash (cdr Program)) (goto is-not-empty)))
           (is-assign . ((if (equal? (second Action) ':=) goto do-assign goto is-goto)))
           (is-goto . ((if (equal? (first Action) 'goto) goto do-goto goto is-if)))
           (is-if . ((if (equal? (first Action) 'if) goto do-if goto is-return)))
           (is-not-empty . ((if (null? AssignJump) goto error goto cont)))
           (is-return . ((if (equal? (first Action) 'return) goto do-return goto error))))
    (fourth Command)
    ())
   (if (empty? BB) goto 18 goto 2))
  (17
   (BB
    :=
    hash-ref
    '#hash((cont . ((Action := car AssignJump) (goto is-assign)))
           (do-assign . ((Env := dict-set Env (car Action) (int-expr Env (unqu (cddr Action)))) (AssignJump := cdr AssignJump) (goto is-not-empty)))
           (do-goto . ((AssignJump := dict-ref Program (second Action)) (goto is-not-empty)))
           (do-if . ((if (int-expr Env (second Action)) goto if-true goto if-false)))
           (do-return . ((return (int-expr Env (unqu (cdr Action))))))
           (error . ((return ('syntaxerror))))
           (if-false . ((AssignJump := dict-ref Program (sixth Action)) (goto is-not-empty)))
           (if-true . ((AssignJump := dict-ref Program (fourth Action)) (goto is-not-empty)))
           (int . ((Env := make-immutable-hash (zip (cdar Program) Env)) (AssignJump := cdadr Program) (Program := make-immutable-hash (cdr Program)) (goto is-not-empty)))
           (is-assign . ((if (equal? (second Action) ':=) goto do-assign goto is-goto)))
           (is-goto . ((if (equal? (first Action) 'goto) goto do-goto goto is-if)))
           (is-if . ((if (equal? (first Action) 'if) goto do-if goto is-return)))
           (is-not-empty . ((if (null? AssignJump) goto error goto cont)))
           (is-return . ((if (equal? (first Action) 'return) goto do-return goto error))))
    (sixth Command)
    ())
   (if (empty? BB) goto 18 goto 2))
  (18 (Res := append Res (list Code)) (if (set-empty? Pending) goto 12 goto 1)))
`source`:
'((if 0 goto 3) (right) (goto 0) (write 1))
`fc-target-3`:
'((read Env)
  (0 (Env := make-immutable-hash (zip '(name namelist valuelist) Env)) (if (int-expr Env '(equal? name (car namelist))) goto 1 goto 2))
  (1 (return (int-expr Env '(car valuelist))))
  (2
   (Env := dict-set Env 'valuelist (int-expr Env '(cdr valuelist)))
   (Env := dict-set Env 'namelist (int-expr Env '(cdr namelist)))
   (if (int-expr Env '(equal? name (car namelist))) goto 1 goto 2)))
check `fc-target-3`:
#t
